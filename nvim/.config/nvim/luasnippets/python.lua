local ls = require('luasnip')
local s = ls.snippet
local t = ls.text_node
local i = ls.insert_node

ls.add_snippets('python', {
  s('#!', t("#!/usr/bin/env python3")),
  s('ilerp', t({
    '# See Freya Holmer "The simple yet powerful math we don\'t talk about":',
    '#     https://www.youtube.com/watch?v=R6UB7mVO3fY',
    '# This is the "official" lerp, but it\'s about 10% slower than the one with only',
    '# a single multiplication below.',
    '# _lerp     = lambda a, b, t: (1 - t) * a + b * t',
    '_lerp     = lambda a, b, t: t * (b - a) + a',
    '_inv_lerp = lambda a, b, v: (v - a) / (b - a)',
    '_remap    = lambda a0, a1, b0, b1, v: _lerp(b0, b1, _inv_lerp(a0, a1, v))',
  })),
  s('"""m', t({
    '"""I hate this line being here',
    '',
    '... rest of the docstring',
    '',
    'Example:',
    '    ...',
    '',
    'Attributes:',
    '    attrib1',
    '    module_level_variable1 (int): Module level variables may be documented in',
    '        either the ``Attributes`` section of the module docstring, or in an',
    '        inline docstring immediately following the variable.',
    '',
    '        Either form is acceptable, but the two should not be mixed. Choose',
    '        one convention to document module level variables and be consistent',
    '        with it.',
    '',
    'Todo:',
    '    * For module TODOs',
    '    * You have to also use ``sphinx.ext.todo`` extension',
    '',
    '.. _Google Python Style Guide:',
    '   http://google.github.io/styleguide/pyguide.html',
    '"""',
  })),
  s('"""f', t({
    '"""Example function or class method with PEP 484 type annotations.',
    '',
    'The return type must be duplicated in the docstring to comply',
    'with the NumPy docstring style.',
    '',
    'Note: Don\'t include the `self` parameter.',
    '',
    'Parameters',
    '----------',
    'param1',
    '    The first parameter.',
    'param2',
    '    The second parameter.',
    '',
    'Returns',
    '-------',
    'bool',
    '    True if successful, False otherwise.',
    '',
    'Raises',
    '------',
    'Exception',
    '    True if successful, False otherwise.',
    '"""',
  })),
  s('pgmin', t({
    '#!/bin/env python3',
    '',
    'import pygame',
    '',
    'TITLE = \'pygame minimal template\'',
    'SCREEN = pygame.Rect(0, 0, 1024, 768)',
    'FPS = 60',
    'DT_MAX = 3 / FPS',
    '',
    'pygame.init()',
    'clock = pygame.time.Clock()',
    'pygame.display.set_caption(TITLE)',
    'screen = pygame.display.set_mode(SCREEN.size)',
    '',
    'running = True',
    'while running:',
    '    dt = min(clock.tick(FPS) / 1000.0, DT_MAX)',
    '',
    '    for e in pygame.event.get():',
    '        if e.type == pygame.QUIT:',
    '            running = False',
    '        elif e.type == pygame.KEYDOWN:',
    '            if e.key == pygame.K_ESCAPE:',
    '                running = False',
    '',
    '    screen.fill(\'black\')',
    '',
    '    ...',
    '',
    '    pygame.display.flip()',
    '    pygame.display.set_caption(f\'{TITLE} - time={pygame.time.get_ticks()/1000:.2f}  fps={clock.get_fps():.2f}\')',
  })),
  s('sdl2', t({
    '#!/bin/env python3',
    '',
    'import pygame',
    'import pygame._sdl2 as sdl2',
    '',
    'TITLE = \'pygame minimal template\'',
    'SCREEN = pygame.Rect(0, 0, 1024, 768)',
    'FPS = 60',
    'DT_MAX = 3 / FPS',
    '',
    'clock = pygame.time.Clock()',
    'window = pygame.Window(title=TITLE, size=SCREEN.size)',
    'renderer = sdl2.Renderer(window)',
    '',
    'running = True',
    'while running:',
    '    dt = min(clock.tick(FPS) / 1000.0, DT_MAX)',
    '',
    '    for e in pygame.event.get():',
    '        if e.type == pygame.QUIT:',
    '            running = False',
    '        elif e.type == pygame.KEYDOWN:',
    '            if e.key == pygame.K_ESCAPE:',
    '                running = False',
    '',
    '    renderer.clear()',
    '    ...',
    '    renderer.present()',
    '',
    '    window.title = f\'{TITLE} - time={pygame.time.get_ticks() / 1000:.2f}  fps={clock.get_fps():.2f}\'',
  })),
  s('bench', t({
    'from statistics import mean, median, stdev',
    'from timeit import timeit',
    '',
    'def bench(*fns, runs=5, number=1_000_000):',
    '    for fn in fns:',
    '        print(fn)',
    '        print(\'-\' * 72)',
    '        timings = []',
    '        for i in range(runs):',
    '            timings.append(timeit(fn, number=number))',
    '            print(f\'{i}: {timings[-1]}\')',
    '',
    -- '        print(f\'{mean(timings)=:.5f}  {median(timings)=:.5f}  {stdev(timings):.5f}\')',
    '        print(f\'{mean(timings)=:.5f}  {median(timings)=:.5f}  {stdev(timings)=:.5f}\')',
  })),
  -- s('bench', t({
  --   'from statistics import mean, median, stdev',
  --   'from timeit import timeit',
  --   '',
  --   'def bench(*fns, runs=5, number=1_000_000):',
  --   '    for fn in fns:',
  --   '        print(fn)',
  --   '        print(\'-\' * 72)',
  --   '        timings = []',
  --   '        for i in range(runs):',
  --   '            timings.append(timeit(fn, number=number))',
  --   '            print(f\'{i}: {timings[-1]}\')',
  --   '',
  --   '        print(f\'{mean(timings)=:.5f}  {median(timings)=:.5f}  {stdev(timings)=:.5f}\\n\')',
  -- })),
  s('longbench', t({
    'def bench(*fns, runs=5, number=1_000_000) -> None:',
    '    summary = []',
    '    outer_timings = []',
    '    for fn in fns:',
    '        print(fn.__name__)',
    '        print(\'-\' * 72)',
    '        timings = []',
    '        for i in range(runs):',
    '            timings.append(timeit(fn, number=number))',
    '            print(f\'{i}: {timings[-1]}\')',
    '',
    '        outer_timings.append((fn.__name__, mean(timings), median(timings)))',
    '        summary.append(',
    '            f\'{outer_timings[-1][0]}: \'',
    '            f\'mean={outer_timings[-1][1]:.5f}  \'',
    '            f\'median={outer_timings[-1][2]:.5f}  \'',
    '            f\'stdev={stdev(timings):.5f}\')',
    '        print(summary[-1], end=\'\\n\\n\')',
    '',
    '    ordered_means = sorted(outer_timings, key=lambda x: x[1])',
    '    ordered_medians = sorted(outer_timings, key=lambda x: x[2])',
    '',
    '    outer_mean = mean([_[1] for _ in outer_timings])',
    '    outer_median = median([_[2] for _ in outer_timings])',
    '    outer_stdev = (stdev([_[1] for _ in outer_timings]),',
    '                   stdev([_[2] for _ in outer_timings]))',
    '',
    '    print(f"""{\'=\' * 72}',
    '{\'\\n\'.join(summary)}',
    '',
    'Mean over runs: {outer_mean:.5f} --> {\', \'.join([_[0] for _ in ordered_means])}',
    'Median over runs: {outer_median:.5f} --> {\', \'.join([_[0] for _ in ordered_medians])}',
    'Stdev over means runs: {outer_stdev[0]:.5f}',
    'Stdev over medians runs: {outer_stdev[1]:.5f}',
    '',
    '""")',
    '',
    'fns = [f1, f2, f3, ...]',
    'shuffle(fns)',
    '',
    'bench(*fns, number=10_000)',
  })),
  s('descriptor', t({
    'from typing import Type, TypeVar',
    '',
    'T = TypeVar("T")',
    '',
    '',
    'class MyDescriptor[T]:',
    '    def __set_name__(self, obj: object, name: str) -> None:',
    '        self.attrib = f\'__my_descriptor_{name}\'',
    '',
    '    def __set__(self, obj: T, val: T) -> None:',
    '        obj.__setattr__(self.attrib, val)',
    '',
    '    def __get__(self, obj: T | None, objtype: Type[T]) -> T:',
    '        if obj is None: return self',
    '',
    '        return obj.__getattribute__(self.attrib)',
  })),
})
